From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Siroshun09 <siro.shun8@gmail.com>
Date: Sun, 5 Nov 2023 19:47:18 +0900
Subject: [PATCH] Paper Fixes


diff --git a/src/main/java/net/minecraft/network/VarInt.java b/src/main/java/net/minecraft/network/VarInt.java
index 18d5a22ad3ef4cb279475531dbc2c65e07c69929..3f362eb42587b333e27b9cf25588a9cfcb8a56e7 100644
--- a/src/main/java/net/minecraft/network/VarInt.java
+++ b/src/main/java/net/minecraft/network/VarInt.java
@@ -9,6 +9,18 @@ public class VarInt {
     private static final int DATA_BITS_PER_BYTE = 7;
 
     public static int getByteSize(int i) {
+    // Paper start - Optimize VarInts
+        return VARINT_EXACT_BYTE_LENGTHS[Integer.numberOfLeadingZeros(i)];
+    }
+    private static final int[] VARINT_EXACT_BYTE_LENGTHS = new int[33];
+    static {
+        for (int i = 0; i <= 32; ++i) {
+            VARINT_EXACT_BYTE_LENGTHS[i] = (int) Math.ceil((31d - (i - 1)) / 7d);
+        }
+        VARINT_EXACT_BYTE_LENGTHS[32] = 1; // Special case for the number 0.
+    }
+    public static int getByteSizeOld(int i) {
+    //Paper end - Optimize VarInts
         for(int j = 1; j < 5; ++j) {
             if ((i & -1 << j * 7) == 0) {
                 return j;
@@ -39,6 +51,21 @@ public class VarInt {
     }
 
     public static ByteBuf write(ByteBuf buf, int i) {
+     // Paper start - Optimize VarInts
+        // Peel the one and two byte count cases explicitly as they are the most common VarInt sizes
+        // that the proxy will write, to improve inlining.
+        if ((i & (0xFFFFFFFF << 7)) == 0) {
+            buf.writeByte(i);
+        } else if ((i & (0xFFFFFFFF << 14)) == 0) {
+            int w = (i & 0x7F | 0x80) << 8 | (i >>> 7);
+            buf.writeShort(w);
+        } else {
+            writeOld(buf, i);
+        }
+        return buf;
+    }
+    public static ByteBuf writeOld(ByteBuf buf, int i) {
+    // Paper end - Optimize VarInts
         while((i & -128) != 0) {
             buf.writeByte(i & 127 | 128);
             i >>>= 7;
diff --git a/src/main/java/net/minecraft/network/protocol/common/ServerboundCustomPayloadPacket.java b/src/main/java/net/minecraft/network/protocol/common/ServerboundCustomPayloadPacket.java
index 975da2529d18391ed4ecc7359a2d7319129bd872..0e5a22d0957cc89ecc65debbff575481f914e4d9 100644
--- a/src/main/java/net/minecraft/network/protocol/common/ServerboundCustomPayloadPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/common/ServerboundCustomPayloadPacket.java
@@ -12,7 +12,7 @@ import net.minecraft.resources.ResourceLocation;
 public record ServerboundCustomPayloadPacket(CustomPacketPayload payload) implements Packet<ServerCommonPacketListener> {
 
     private static final int MAX_PAYLOAD_SIZE = 32767;
-    private static final Map<ResourceLocation, FriendlyByteBuf.Reader<? extends CustomPacketPayload>> KNOWN_TYPES = ImmutableMap.<ResourceLocation, FriendlyByteBuf.Reader<? extends CustomPacketPayload>>builder().put(BrandPayload.ID, BrandPayload::new).build(); // CraftBukkit - decompile error
+    private static final Map<ResourceLocation, FriendlyByteBuf.Reader<? extends CustomPacketPayload>> KNOWN_TYPES = ImmutableMap.<ResourceLocation, FriendlyByteBuf.Reader<? extends CustomPacketPayload>>builder().build(); // CraftBukkit - no special handling
 
     public ServerboundCustomPayloadPacket(FriendlyByteBuf buf) {
         this(readPayload(buf.readResourceLocation(), buf));
diff --git a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
index 5dfb35117c285e0b202dc9c088ad5848beb8d054..a043c382c37058032548a5192e17f5f816abe5a6 100644
--- a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
+++ b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
@@ -309,9 +309,12 @@ public class SynchedEntityData {
             return;
         }
 
-        net.minecraft.server.level.ServerEntity serverEntity = this.entity.tracker.serverEntity;
         if (player.getBukkitEntity().canSee(entity.getBukkitEntity())) {
-            serverEntity.sendPairingData(player, player.connection::send);
+            net.minecraft.server.level.ServerEntity serverEntity = this.entity.tracker.serverEntity;
+
+            List<net.minecraft.network.protocol.Packet<net.minecraft.network.protocol.game.ClientGamePacketListener>> list = new ArrayList<>();
+            serverEntity.sendPairingData(player, list::add);
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundBundlePacket(list));
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index a9fe3d1c0fc217bd32e884c9e75c906d8b4bf967..207570cab4b0e3257a5b80198a0032c2d972d89c 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -638,7 +638,11 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     public boolean enforceSecureProfile() {
         DedicatedServerProperties dedicatedserverproperties = this.getProperties();
 
-        return dedicatedserverproperties.enforceSecureProfile && dedicatedserverproperties.onlineMode && this.services.profileKeySignatureValidator() != null;
+        // Paper start - fix secure profile with proxy online mode
+        return dedicatedserverproperties.enforceSecureProfile
+                && io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()
+                && this.services.profileKeySignatureValidator() != null;
+        // Paper end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 54fb3f603f2e69eb8fe0094f78dcc79065a11e46..105d49677e71f735a185ceec17e581f59ee7027d 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3723,7 +3723,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
     public void take(Entity item, int count) {
         if (!item.isRemoved() && !this.level().isClientSide && (item instanceof ItemEntity || item instanceof AbstractArrow || item instanceof ExperienceOrb)) {
-            ((ServerLevel) this.level()).getChunkSource().broadcast(item, new ClientboundTakeItemEntityPacket(item.getId(), this.getId(), count));
+            ((ServerLevel) this.level()).getChunkSource().broadcastAndSend(this, new ClientboundTakeItemEntityPacket(item.getId(), this.getId(), count)); // Paper - broadcast with collector as source
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Zombie.java b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
index ef61663d9ba41cf02a03800c74d4ce4ccc5faec5..2f5b8933404402716caaa2484e5ec0383698e7a4 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Zombie.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
@@ -454,8 +454,8 @@ public class Zombie extends Monster {
     public boolean killedEntity(ServerLevel world, LivingEntity other) {
         boolean flag = super.killedEntity(world, other);
 
-        final double fallbackChance = world.getDifficulty() == Difficulty.HARD ? 1d : world.getDifficulty() == Difficulty.NORMAL ? 0.5d : 0d; // Paper
-        if (this.random.nextDouble() < world.paperConfig().entities.behavior.zombieVillagerInfectionChance.or(fallbackChance) && other instanceof Villager entityvillager) { // Paper
+        final double fallbackChance = world.getDifficulty() == Difficulty.HARD ? 100d : world.getDifficulty() == Difficulty.NORMAL ? 50d : 0d; // Paper
+        if (this.random.nextDouble() * 100 < world.paperConfig().entities.behavior.zombieVillagerInfectionChance.or(fallbackChance) && other instanceof Villager entityvillager) { // Paper
             // CraftBukkit start
             flag = Zombie.zombifyVillager(world, entityvillager, this.blockPosition(), this.isSilent(), CreatureSpawnEvent.SpawnReason.INFECTION) == null;
         }
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index ffd349c1b80df0f1e8c02bda23700184825170fd..f664da5a8413bb13cc95d2cf1604f11a5d285dae 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -599,7 +599,7 @@ public abstract class AbstractContainerMenu {
                 int j2;
 
                 if (actionType == ClickType.SWAP) {
-                    if (slotIndex < 0) return; // Paper
+                    if (slotIndex < 0 || button < 0) return; // Paper
                     slot2 = (Slot) this.slots.get(slotIndex);
                     itemstack1 = playerinventory.getItem(button);
                     itemstack = slot2.getItem();
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 44c09217241fae975fa4f734dfc5be4b03094e73..ad3d8260aa275c0886c006c9ba3dd67e888502ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1072,7 +1072,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void sendEquipmentChange(LivingEntity entity, EquipmentSlot slot, ItemStack item) {
-        this.sendEquipmentChange(entity, Map.of(slot, item));
+        this.sendEquipmentChange(entity, java.util.Collections.singletonMap(slot, item)); // Paper - replace Map.of to allow null values
     }
 
     @Override
